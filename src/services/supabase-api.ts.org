import { supabase } from '../lib/supabase'
import { Building, SearchFilters, Architect, Photo, NewArchitect } from '../types'
import { sessionManager } from '../utils/session-manager'
import { BuildingSearchEngine } from './BuildingSearchEngine'
//import { BuildingSearchViewService } from './building-search-view'

export class SupabaseApiError extends Error {
  constructor(public status: number, message: string) {
    super(message);
    this.name = 'SupabaseApiError';
  }
}

class SupabaseApiClient {
  private searchEngine: BuildingSearchEngine;
//  private buildingSearchViewService: BuildingSearchViewService;

  constructor() {
    this.searchEngine = new BuildingSearchEngine();
//    this.buildingSearchViewService = new BuildingSearchViewService();
  }
  // å»ºç¯‰ç‰©é–¢é€£API
  async getBuildings(page: number = 1, limit: number = 10): Promise<{ buildings: Building[], total: number }> {
    console.log('Supabase getBuildings called:', { page, limit });
    
    const start = (page - 1) * limit;
    const end = start + limit - 1;

    const { data: buildings, error, count } = await supabase
      .from('buildings_table_2')
      .select(`
        *,
        building_architects(
          architect_id,
          architect_order
        )
      `, { count: 'exact' })
      .not('lat', 'is', null)
      .not('lng', 'is', null)
      .range(start, end)
      .order('building_id', { ascending: false });

    console.log('Supabase response:', { buildings: buildings?.length, error, count });

    if (error) {
      console.error('Supabase error:', error);
      throw new SupabaseApiError(500, error.message);
    }

    // ãƒ‡ãƒ¼ã‚¿å¤‰æ›
    const transformedBuildings: Building[] = [];
    if (buildings) {
      for (const building of buildings) {
        try {
          const transformed = await this.transformBuilding(building);
          transformedBuildings.push(transformed);
        } catch (error) {
          console.warn('Skipping building due to invalid data:', error);
          // ç„¡åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã®å»ºç¯‰ç‰©ã¯ã‚¹ã‚­ãƒƒãƒ—
        }
      }
    }
    console.log('Transformed buildings:', transformedBuildings.length);

    return {
      buildings: transformedBuildings,
      total: count || 0
    };
  }

  async getBuildingById(id: number): Promise<Building> {
    const { data: building, error } = await supabase
      .from('buildings_table_2')
      .select(`
        *,
        building_architects!inner(
          architect_id,
          architect_order
        )
      `)
      .eq('building_id', id)
      .single();

    if (error) {
      throw new SupabaseApiError(404, error.message);
    }

    return await this.transformBuilding(building);
  }

  async getBuildingBySlug(slug: string): Promise<Building> {
    const { data: building, error } = await supabase
      .from('buildings_table_2')
      .select(`
        *,
        building_architects!inner(
          architect_id,
          architect_order
        )
      `)
      .eq('slug', slug)
      .single();

    if (error) {
      throw new SupabaseApiError(404, error.message);
    }

    return await this.transformBuilding(building);
  }



  async searchBuildings(
    filters: SearchFilters,
    page: number = 1,
    limit: number = 10,
    language: 'ja' | 'en' = 'ja'
  ): Promise<{ buildings: Building[], total: number }> {
    // åœ°ç‚¹æ¤œç´¢ãŒæœ‰åŠ¹ãªå ´åˆã¯ã€PostGISã®ç©ºé–“é–¢æ•°ã‚’ä½¿ç”¨
    if (filters.currentLocation) {
      return this.searchBuildingsWithDistance(filters, page, limit, language);
    }

    console.log('ğŸ” ãƒ“ãƒ¥ãƒ¼æ¤œç´¢é–‹å§‹:', { filters, language, page, limit });

    try {
      // æ–°ã—ã„ãƒ“ãƒ¥ãƒ¼æ¤œç´¢ã‚µãƒ¼ãƒ“ã‚¹ã‚’ä½¿ç”¨
      const result = await this.buildingSearchViewService.searchBuildings(filters, language, page, limit);
      
      console.log('âœ… ãƒ“ãƒ¥ãƒ¼æ¤œç´¢å®Œäº†:', {
        resultCount: result.data.length,
        totalCount: result.count,
        page: result.page,
        totalPages: result.totalPages
      });

      // ãƒ‡ãƒ¼ã‚¿å¤‰æ›
      const transformedBuildings: Building[] = [];
      for (const building of result.data) {
        try {
          const transformed = await this.transformBuildingFromView(building);
          transformedBuildings.push(transformed);
        } catch (error) {
          console.warn('ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
        }
      }

      return {
        buildings: transformedBuildings,
        total: result.count
      };

    } catch (error) {
      console.error('âŒ ãƒ“ãƒ¥ãƒ¼æ¤œç´¢ã§ã‚¨ãƒ©ãƒ¼:', error);
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨
      console.log(' ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®æ¤œç´¢ã‚¨ãƒ³ã‚¸ãƒ³ã‚’ä½¿ç”¨');
      return this.searchBuildingsWithFallback(filters, page, limit, language);
    }
  }

  // åœ°ç‚¹æ¤œç´¢ç”¨ã®é–¢æ•°ï¼šPostGISé–¢æ•°ãŒå­˜åœ¨ã—ãªã„ãŸã‚ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢ã‚’ä½¿ç”¨
  private async searchBuildingsWithDistance(
    filters: SearchFilters,
    page: number = 1,
    limit: number = 10,
    language: 'ja' | 'en' = 'ja'
  ): Promise<{ buildings: Building[], total: number }> {
    console.log('ğŸ” PostGISé–¢æ•°ãŒå­˜åœ¨ã—ãªã„ãŸã‚ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢ã‚’ä½¿ç”¨');
    
    // PostGISé–¢æ•°ãŒå­˜åœ¨ã—ãªã„ãŸã‚ã€ç›´æ¥ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢ã‚’ä½¿ç”¨
    return this.searchBuildingsWithFallback(filters, page, limit, language);
  }

  // IDé…åˆ—ã‹ã‚‰å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
  private async getArchitectsByIds(architectIds: number[]): Promise<Architect[]> {
    try {
      const { data, error } = await supabase
        .from('architect_compositions')
        .select(`
          architect_id,
          order_index,
          individual_architects!inner(
            individual_architect_id,
            name_ja,
            name_en,
            slug
          )
        `)
        .in('architect_id', architectIds)
        .order('order_index');

      if (error || !data) {
        console.warn('å»ºç¯‰å®¶æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        return [];
      }

      // çµæœã‚’å¹³å¦åŒ–ã—ã¦é…åˆ—ã«å¤‰æ›
      const architects = data
        .map((comp: any) => ({
          architect_id: comp.architect_id,
          individual_architect_id: comp.individual_architect_id,
          architectJa: comp.individual_architects.name_ja,
          architectEn: comp.individual_architects.name_en,
          slug: comp.individual_architects.slug,
          order_index: comp.order_index,
          websites: []
        }))
        .filter(architect => architect !== null);

      return architects;
    } catch (error) {
      console.error('å»ºç¯‰å®¶æƒ…å ±å–å¾—ã§ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }
  }

  // ãƒ“ãƒ¥ãƒ¼ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰Buildingã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å¤‰æ›
  private async transformBuildingFromView(buildingView: any): Promise<Building> {
    // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    console.log('ğŸ” transformBuildingFromView Debug:', {
      buildingId: buildingView.building_id,
      title: buildingView.title,
      location: buildingView.location,
      locationEn_from_datasheetChunkEn: buildingView.locationEn_from_datasheetChunkEn,
      locationEn_from_datasheetChunkEnType: typeof buildingView.locationEn_from_datasheetChunkEn,
      buildingViewKeys: Object.keys(buildingView),
      hasLocationEnField: 'locationEn_from_datasheetChunkEn' in buildingView,
      buildingViewRaw: buildingView
    });

    // å»ºç¯‰å®¶æƒ…å ±ã®å‡¦ç†
    let architects: Architect[] = [];
    if (buildingView.architect_ids && buildingView.architect_ids.length > 0) {
      architects = await this.getArchitectsByIds(buildingView.architect_ids);
    }

    // æ–‡å­—åˆ—ã‚’é…åˆ—ã«å¤‰æ›ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
    const parseSlashSeparated = (value: any): string[] => {
      if (!value) return [];
      if (Array.isArray(value)) return value;
      if (typeof value === 'string') {
        return value.split('/').map(v => v.trim()).filter(v => v);
      }
      return [];
    };

    const transformedBuilding = {
      id: buildingView.building_id,
      uid: buildingView.uid,
      title: buildingView.title,
      titleEn: buildingView.titleEn,
      thumbnailUrl: buildingView.thumbnailUrl,
      youtubeUrl: buildingView.youtubeUrl,
      completionYears: buildingView.completionYears,
      parentBuildingTypes: [], // ãƒ“ãƒ¥ãƒ¼ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ç©ºé…åˆ—
      buildingTypes: parseSlashSeparated(buildingView.buildingTypes),
      buildingTypesEn: parseSlashSeparated(buildingView.buildingTypesEn),
      parentStructures: [], // ãƒ“ãƒ¥ãƒ¼ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ç©ºé…åˆ—
      structures: [], // ãƒ“ãƒ¥ãƒ¼ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ç©ºé…åˆ—
      prefectures: buildingView.prefectures,
      prefecturesEn: buildingView.prefecturesEn,
      areas: buildingView.areas,
      areasEn: buildingView.areasEn,
      location: buildingView.location,
      locationEn: buildingView.locationEn_from_datasheetChunkEn,
      architectDetails: '', // ãƒ“ãƒ¥ãƒ¼ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ç©ºæ–‡å­—
      lat: buildingView.lat,
      lng: buildingView.lng,
      slug: buildingView.slug,
      architects,
      photos: [], // ç©ºã®é…åˆ—ã‚’è¨­å®šï¼ˆãƒ“ãƒ¥ãƒ¼ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ï¼‰
      likes: 0, // ãƒ“ãƒ¥ãƒ¼ã«ã¯å«ã¾ã‚Œã¦ã„ãªã„ãŸã‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
      created_at: buildingView.created_at,
      updated_at: buildingView.updated_at
    };

    console.log('ğŸ” transformBuildingFromView Result:', {
      buildingId: transformedBuilding.id,
      locationEn: transformedBuilding.locationEn,
      locationEnType: typeof transformedBuilding.locationEn
    });

    return transformedBuilding;
  }

  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ã®æ—¢å­˜æ¤œç´¢ï¼ˆçµ±åˆç‰ˆï¼‰
  private async searchBuildingsWithFallback(
    filters: SearchFilters,
    page: number = 1,
    limit: number = 10,
    language: 'ja' | 'en' = 'ja'
  ): Promise<{ buildings: Building[], total: number }> {
    console.log('ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢å®Ÿè¡Œ - BuildingSearchViewServiceä½¿ç”¨');
    
    try {
      // BuildingSearchViewServiceã‚’ä½¿ç”¨ã—ã¦æ¤œç´¢ã‚’å®Ÿè¡Œ
      console.log('ğŸ” BuildingSearchViewServiceå‘¼ã³å‡ºã—å‰:', { filters, page, limit, language });
      
      const result = await this.buildingSearchViewService.searchBuildings(
        filters,
        language,
        page,
        limit
      );
      
      console.log('ğŸ” BuildingSearchViewServiceå‘¼ã³å‡ºã—å¾Œ:', result);
      
      // åœ°ç‚¹æ¤œç´¢ã®å ´åˆã¯è·é›¢è¨ˆç®—ã¨ã‚½ãƒ¼ãƒˆã‚’è¿½åŠ 
      if (filters.currentLocation && result.data && result.data.length > 0) {
        console.log('ğŸ“ åœ°ç‚¹æ¤œç´¢: è·é›¢è¨ˆç®—ã¨ã‚½ãƒ¼ãƒˆã‚’å®Ÿè¡Œ');
        
        // BuildingSearchViewServiceã§æ—¢ã«è·é›¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒé©ç”¨ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€
        // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«ã§ã®è·é›¢ã‚½ãƒ¼ãƒˆçµæœã‚’å°Šé‡ã—ã€å†åº¦ã‚½ãƒ¼ãƒˆã¯è¡Œã‚ãªã„
        if (result.data[0].distance !== undefined) {
          console.log('ğŸ” BuildingSearchViewServiceã§æ—¢ã«è·é›¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ¸ˆã¿ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«ã§ã®ã‚½ãƒ¼ãƒˆçµæœã‚’å°Šé‡');
          
          // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«ã§ã®è·é›¢ã‚½ãƒ¼ãƒˆçµæœã‚’ç¢ºèª
          console.log('ğŸ” ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ¬ãƒ™ãƒ«ã§ã®è·é›¢ã‚½ãƒ¼ãƒˆçµæœ:', {
            totalBuildings: result.data.length,
            sortedDistances: result.data.slice(0, 10).map(b => ({
              title: b.title,
              distance: (b as any).distance
            }))
          });
          
          // ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’å¤‰æ›ï¼ˆã‚½ãƒ¼ãƒˆã¯è¡Œã‚ãªã„ï¼‰
          const transformedBuildings = result.data.map((building: any) => ({
            id: building.building_id,
            uid: building.uid,
            slug: building.slug,
            title: building.title,
            titleEn: building.titleEn,
            thumbnailUrl: building.thumbnailUrl,
            youtubeUrl: building.youtubeUrl,
            completionYears: building.completionYears,
            parentBuildingTypes: building.parentBuildingTypes ? building.parentBuildingTypes.split(' / ') : [],
            buildingTypes: building.buildingTypes ? building.buildingTypes.split(' / ') : [],
            parentStructures: building.parentStructures ? building.parentStructures.split(' / ') : [],
            structures: building.structures ? building.structures.split(' / ') : [],
            prefectures: building.prefectures,
            prefecturesEn: building.prefecturesEn,
            areas: building.areas,
            location: building.location,
            locationEn: building.locationEn,
            buildingTypesEn: building.buildingTypesEn ? building.buildingTypesEn.split(' / ') : [],
            architectDetails: building.architectDetails,
            lat: building.lat,
            lng: building.lng,
            distance: (building as any).distance,
            architects: building.architect_ids ? building.architect_ids.map((architectId: number, index: number) => ({
              architect_id: architectId,
              architectJa: building.architect_names_ja ? building.architect_names_ja.split(',')[index]?.trim() : '',
              architectEn: building.architect_names_en ? building.architect_names_en.split(',')[index]?.trim() : '',
              slug: '', // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
              websites: []
            })) : [],
            photos: [], // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            likes: 0, // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            created_at: building.created_at,
            updated_at: building.updated_at
          }));
          
          return {
            buildings: transformedBuildings,
            total: result.count
          };
        }
        
        // å¾“æ¥ã®å‡¦ç†ï¼ˆBuildingSearchViewServiceã§è·é›¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãŒé©ç”¨ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰
        console.log('ğŸ” å¾“æ¥ã®è·é›¢è¨ˆç®—ã¨ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’å®Ÿè¡Œ');
        
        // è·é›¢ã‚’è¨ˆç®—ã—ã¦å„å»ºç¯‰ç‰©ã«è¿½åŠ 
        const buildingsWithDistance = result.data.map(building => {
          const distance = this.haversineKm(
            filters.currentLocation!.lat,
            filters.currentLocation!.lng,
            building.lat || 0,
            building.lng || 0
          );
          return { ...building, distance };
        });
        
        // radiusã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆè·é›¢ãŒæŒ‡å®šã•ã‚ŒãŸåŠå¾„å†…ã®å»ºç¯‰ç‰©ã®ã¿ï¼‰
        if (filters.radius) {
          const radiusFiltered = buildingsWithDistance.filter(building => 
            (building as any).distance <= filters.radius!
          );
          
          console.log('ğŸ” radiusãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµæœ:', {
            beforeFiltering: buildingsWithDistance.length,
            afterFiltering: radiusFiltered.length,
            radius: filters.radius,
            maxDistance: Math.max(...radiusFiltered.map(b => (b as any).distance || 0))
          });
          
          // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å¾Œã®çµæœã§ã‚½ãƒ¼ãƒˆ
          radiusFiltered.sort((a, b) => {
            const distanceA = (a as any).distance || Infinity;
            const distanceB = (b as any).distance || Infinity;
            return distanceA - distanceB;
          });
          
          // ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’å¤‰æ›
          const transformedBuildings = radiusFiltered.map((building: any) => ({
            id: building.building_id,
            uid: building.uid,
            slug: building.slug,
            title: building.title,
            titleEn: building.titleEn,
            thumbnailUrl: building.thumbnailUrl,
            youtubeUrl: building.youtubeUrl,
            completionYears: building.completionYears,
            parentBuildingTypes: building.parentBuildingTypes ? building.parentBuildingTypes.split(' / ') : [],
            buildingTypes: building.buildingTypes ? building.buildingTypes.split(' / ') : [],
            parentStructures: building.parentStructures ? building.parentStructures.split(' / ') : [],
            structures: building.structures ? building.structures.split(' / ') : [],
            prefectures: building.prefectures,
            prefecturesEn: building.prefecturesEn,
            areas: building.areas,
            location: building.location,
            locationEn: building.locationEn,
            buildingTypesEn: building.buildingTypesEn ? building.buildingTypesEn.split(' / ') : [],
            architectDetails: building.architectDetails,
            lat: building.lat,
            lng: building.lng,
            distance: (building as any).distance,
            architects: building.architect_ids ? building.architect_ids.map((architectId: number, index: number) => ({
              architect_id: architectId,
              architectJa: building.architect_names_ja ? building.architect_names_ja.split(',')[index]?.trim() : '',
              architectEn: building.architect_names_en ? building.architect_names_en.split(',')[index]?.trim() : '',
              slug: '', // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
              websites: []
            })) : [],
            photos: [], // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            likes: 0, // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            created_at: building.created_at,
            updated_at: building.updated_at
          }));
          
          return {
            buildings: transformedBuildings,
            total: radiusFiltered.length
          };
        }
        
        // radiusãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯è·é›¢é †ã«ã‚½ãƒ¼ãƒˆã®ã¿
        buildingsWithDistance.sort((a, b) => {
          const distanceA = (a as any).distance || Infinity;
          const distanceB = (b as any).distance || Infinity;
          return distanceA - distanceB;
        });
        
        // ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’å¤‰æ›
        const transformedBuildings = buildingsWithDistance.map((building: any) => ({
          id: building.building_id,
          uid: building.uid,
          slug: building.slug,
          title: building.title,
          titleEn: building.titleEn,
          thumbnailUrl: building.thumbnailUrl,
          youtubeUrl: building.youtubeUrl,
          completionYears: building.completionYears,
          parentBuildingTypes: building.parentBuildingTypes ? building.parentBuildingTypes.split(' / ') : [],
          buildingTypes: building.buildingTypes ? building.buildingTypes.split(' / ') : [],
          parentStructures: building.parentStructures ? building.parentStructures.split(' / ') : [],
          structures: building.structures ? building.structures.split(' / ') : [],
          prefectures: building.prefectures,
          prefecturesEn: building.prefecturesEn,
          areas: building.areas,
          location: building.location,
          locationEn: building.locationEn,
          buildingTypesEn: building.buildingTypesEn ? building.buildingTypesEn.split(' / ') : [],
          architectDetails: building.architectDetails,
          lat: building.lat,
          lng: building.lng,
          distance: (building as any).distance,
          architects: building.architect_ids ? building.architect_ids.map((architectId: number, index: number) => ({
            architect_id: architectId,
            architectJa: building.architect_names_ja ? building.architect_names_ja.split(',')[index]?.trim() : '',
            architectEn: building.architect_names_en ? building.architect_names_en.split(',')[index]?.trim() : '',
            slug: '', // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            websites: []
          })) : [],
          photos: [], // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
          likes: 0, // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
          created_at: building.created_at,
          updated_at: building.updated_at
        }));
        
        return {
          buildings: transformedBuildings,
          total: result.count
        };
      }
      
      // BuildingSearchViewServiceã®æˆ»ã‚Šå€¤ã‚’é©åˆ‡ãªå½¢å¼ã«å¤‰æ›
      const convertedResult = {
        buildings: result.data || [],
        total: result.count || 0
      };
      
      console.log('ğŸ” å¤‰æ›å¾Œã®æˆ»ã‚Šå€¤:', convertedResult);
      
      return convertedResult;
    } catch (error) {
      console.error('BuildingSearchViewServiceæ¤œç´¢ã§ã‚¨ãƒ©ãƒ¼:', error);
      
      // æœ€å¾Œã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªæ¤œç´¢ã®ã¿
      console.log('âš ï¸ æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åŸºæœ¬çš„ãªæ¤œç´¢ã‚’å®Ÿè¡Œ');
      const basicResult = await this.buildingSearchViewService.searchBuildings(
        { ...filters, currentLocation: undefined }, // åœ°ç‚¹æ¤œç´¢ã‚’ç„¡åŠ¹åŒ–
        language,
        page,
        limit
      );
      
      console.log('ğŸ” æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯çµæœ:', basicResult);
      
      // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§ã‚‚è·é›¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚’é©ç”¨
      if (filters.currentLocation && basicResult.data && basicResult.data.length > 0) {
        console.log('ğŸ“ æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è·é›¢ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é©ç”¨');
        
        const buildingsWithDistance = basicResult.data.map(building => {
          const distance = this.haversineKm(
            filters.currentLocation!.lat,
            filters.currentLocation!.lng,
            building.lat || 0,
            building.lng || 0
          );
          return { ...building, distance };
        });
        
        // radiusã§ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
        if (filters.radius) {
          const radiusFiltered = buildingsWithDistance.filter(building => 
            (building as any).distance <= filters.radius!
          );
          
          console.log('ğŸ” æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ radiusãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµæœ:', {
            beforeFiltering: buildingsWithDistance.length,
            afterFiltering: radiusFiltered.length,
            radius: filters.radius
          });
          
          // ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’å¤‰æ›
          const transformedBuildings = radiusFiltered.map((building: any) => ({
            id: building.building_id,
            uid: building.uid,
            slug: building.slug,
            title: building.title,
            titleEn: building.titleEn,
            thumbnailUrl: building.thumbnailUrl,
            youtubeUrl: building.youtubeUrl,
            completionYears: building.completionYears,
            parentBuildingTypes: building.parentBuildingTypes ? building.parentBuildingTypes.split(' / ') : [],
            buildingTypes: building.buildingTypes ? building.buildingTypes.split(' / ') : [],
            parentStructures: building.parentStructures ? building.parentStructures.split(' / ') : [],
            structures: building.structures ? building.structures.split(' / ') : [],
            prefectures: building.prefectures,
            prefecturesEn: building.prefecturesEn,
            areas: building.areas,
            location: building.location,
            locationEn: building.locationEn,
            buildingTypesEn: building.buildingTypesEn ? building.buildingTypesEn.split(' / ') : [],
            architectDetails: building.architectDetails,
            lat: building.lat,
            lng: building.lng,
            distance: (building as any).distance,
            architects: building.architect_ids ? building.architect_ids.map((architectId: number, index: number) => ({
              architect_id: architectId,
              architectJa: building.architect_names_ja ? building.architect_names_ja.split(',')[index]?.trim() : '',
              architectEn: building.architect_names_en ? building.architect_names_en.split(',')[index]?.trim() : '',
              slug: '', // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
              websites: []
            })) : [],
            photos: [], // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            likes: 0, // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
            created_at: building.created_at,
            updated_at: building.updated_at
          }));
          
          return {
            buildings: transformedBuildings,
            total: radiusFiltered.length
          };
        }
      }
      
      // BuildingSearchViewServiceã®æˆ»ã‚Šå€¤ã‚’é©åˆ‡ãªå½¢å¼ã«å¤‰æ›
      const transformedBuildings = (basicResult.data || []).map((building: any) => ({
        id: building.building_id,
        uid: building.uid,
        slug: building.slug,
        title: building.title,
        titleEn: building.titleEn,
        thumbnailUrl: building.thumbnailUrl,
        youtubeUrl: building.youtubeUrl,
        completionYears: building.completionYears,
        parentBuildingTypes: building.parentBuildingTypes ? building.parentBuildingTypes.split(' / ') : [],
        buildingTypes: building.buildingTypes ? building.buildingTypes.split(' / ') : [],
        parentStructures: building.parentStructures ? building.parentStructures.split(' / ') : [],
        structures: building.structures ? building.structures.split(' / ') : [],
        prefectures: building.prefectures,
        prefecturesEn: building.prefecturesEn,
        areas: building.areas,
        location: building.location,
        locationEn: building.locationEn,
        buildingTypesEn: building.buildingTypesEn ? building.buildingTypesEn.split(' / ') : [],
        architectDetails: building.architectDetails,
        lat: building.lat,
        lng: building.lng,
        architects: building.architect_ids ? building.architect_ids.map((architectId: number, index: number) => ({
          architect_id: architectId,
          architectJa: building.architect_names_ja ? building.architect_names_ja.split(',')[index]?.trim() : '',
          architectEn: building.architect_names_en ? building.architect_names_en.split(',')[index]?.trim() : '',
          slug: '', // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
          websites: []
        })) : [],
        photos: [], // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
        likes: 0, // å¿…è¦ã«å¿œã˜ã¦è¨­å®š
        created_at: building.created_at,
        updated_at: building.updated_at
      }));
      
      const fallbackResult = {
        buildings: transformedBuildings,
        total: basicResult.count || 0
      };
      
      console.log('ğŸ” æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¤‰æ›å¾Œ:', fallbackResult);
      
      return fallbackResult;
    }
  }



  async getNearbyBuildings(lat: number, lng: number, radius: number): Promise<Building[]> {
    // PostGISã‚’ä½¿ç”¨ã—ãŸåœ°ç†ç©ºé–“æ¤œç´¢ï¼ˆSupabaseã§æœ‰åŠ¹åŒ–å¿…è¦ï¼‰
    const { data: buildings, error } = await supabase
      .rpc('nearby_buildings', {
        lat,
        lng,
        radius_km: radius
      });

    if (error) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç°¡æ˜“çš„ãªç¯„å›²æ¤œç´¢
      return this.searchBuildings({
        query: '',
        radius,
        architects: [],
        buildingTypes: [],
        prefectures: [],
        areas: [],
        hasPhotos: false,
        hasVideos: false,
        currentLocation: { lat, lng }
      }).then(result => result.buildings);
    }

    return buildings?.map(this.transformBuilding) || [];
  }

  // ç°¡æ˜“Haversineï¼ˆkmï¼‰
  private haversineKm(lat1: number, lon1: number, lat2: number, lon2: number): number {
    const toRad = (v: number) => (v * Math.PI) / 180;
    const R = 6371;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  // ã„ã„ã­æ©Ÿèƒ½
  async likeBuilding(buildingId: number): Promise<{ likes: number }> {
    const { data, error } = await supabase
      .rpc('increment_building_likes', { building_id: buildingId });

    if (error) {
      throw new SupabaseApiError(500, error.message);
    }

    return { likes: data };
  }

  async likePhoto(photoId: number): Promise<{ likes: number }> {
    const { data, error } = await supabase
      .rpc('increment_photo_likes', { photo_id: photoId });

    if (error) {
      throw new SupabaseApiError(500, error.message);
    }

    return { likes: data };
  }

  // å»ºç¯‰å®¶é–¢é€£
  async getArchitects(): Promise<Architect[]> {
    const { data, error } = await supabase
      .from('individual_architects')
      .select(`
        individual_architect_id,
        name_ja,
        name_en,
        slug,
        architect_compositions!inner(
          architect_id,
          order_index
        )
      `)
      .order('name_ja');

    if (error || !data) {
      throw new SupabaseApiError(500, error?.message || 'failed to fetch individual_architects');
    }

    return data.map(item => {
      const composition = item.architect_compositions.sort((a: any, b: any) => a.order_index - b.order_index)[0];
      return {
        architect_id: composition?.architect_id || 0,
        architectJa: item.name_ja,
        architectEn: item.name_en,
        slug: item.slug,
        websites: []
      };
    });
  }

  // å»ºç¯‰å®¶ã®ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆæƒ…å ±ã‚’å–å¾—
  async getArchitectWebsites(architectId: number) {
    const { data: websites, error } = await supabase
      .from('architect_websites_3')
      .select('*')
      .eq('architect_id', architectId);

    if (error) {
      return [];
    }

    return websites?.map(site => ({
      website_id: site.website_id,
      url: site.url,
      title: site.title,
      invalid: site.invalid,
      architectJa: site.architectJa,
      architectEn: site.architectEn
    })) || [];
  }

  // çµ±è¨ˆãƒ»æ¤œç´¢å€™è£œ
  async getSearchSuggestions(query: string): Promise<string[]> {
    const { data, error } = await supabase
      .from('buildings_table_2')
      .select('title, titleEn')
      .or(`title.ilike.%${query}%,titleEn.ilike.%${query}%`)
      .limit(10);

    if (error) {
      return [];
    }

    const suggestions = new Set<string>();
    data?.forEach(item => {
      if (item.title.toLowerCase().includes(query.toLowerCase())) {
        suggestions.add(item.title);
      }
      if (item.titleEn?.toLowerCase().includes(query.toLowerCase())) {
        suggestions.add(item.titleEn);
      }
    });

    return Array.from(suggestions);
  }

  async getPopularSearches(): Promise<{ query: string; count: number }[]> {
    // æ¤œç´¢ãƒ­ã‚°ãƒ†ãƒ¼ãƒ–ãƒ«ãŒã‚ã‚‹å ´åˆ
    const { data, error } = await supabase
      .from('search_logs')
      .select('query, count')
      .order('count', { ascending: false })
      .limit(10);

    if (error) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å›ºå®šã®äººæ°—æ¤œç´¢
      return [
        { query: 'å®‰è—¤å¿ é›„', count: 45 },
        { query: 'ç¾è¡“é¤¨', count: 38 },
        { query: 'æ±äº¬', count: 32 },
        { query: 'ç¾ä»£å»ºç¯‰', count: 28 }
      ];
    }

    return data || [];
  }

  // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯
  async healthCheck(): Promise<{ status: string; database: string }> {
    const { data, error } = await supabase
      .from('buildings_table_2')
      .select('count')
      .limit(1);

    if (error) {
      throw new SupabaseApiError(500, 'Database connection failed');
    }

    return {
      status: 'ok',
      database: 'supabase'
    };
  }

  // ãƒ‡ãƒ¼ã‚¿å¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼
  private async transformBuilding(data: any): Promise<Building> {
    console.log('Transforming building data:', data);
    
    // ä½ç½®ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ - lat, lngã©ã¡ã‚‰ã‹ãŒNULLã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
    if (data.lat === null || data.lng === null || 
        typeof data.lat !== 'number' || typeof data.lng !== 'number' ||
        isNaN(data.lat) || isNaN(data.lng)) {
      throw new Error(`Invalid coordinates for building ${data.building_id}: lat=${data.lat}, lng=${data.lng}`);
    }

    // buildingTypesãªã©ã®ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã‚’é…åˆ—ã«å¤‰æ›
    const parseCommaSeparated = (str: string | null): string[] => {
      if (!str) return [];
      return str.split(',').map(s => s.trim()).filter(s => s.length > 0);
    };

    // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã‚’é…åˆ—ã«å¤‰æ›ï¼ˆå»ºç‰©ç”¨é€”ç”¨ï¼‰
    const parseSlashSeparated = (str: string | null): string[] => {
      if (!str) return [];
      return str.split('/').map(s => s.trim()).filter(s => s.length > 0);
    };

    // å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šæ–‡å­—åˆ—ã‚’é…åˆ—ã«å¤‰æ›ï¼ˆå»ºç¯‰å®¶ç”¨ï¼‰
    const parseFullWidthSpaceSeparated = (str: string | null): string[] => {
      if (!str) return [];
      return str.split('ã€€').map(s => s.trim()).filter(s => s.length > 0);
    };

    // completionYearsã‚’æ•°å€¤ã«å¤‰æ›
    const parseYear = (year: string | null): number => {
      if (!year) return new Date().getFullYear();
      const parsed = parseInt(year, 10);
      return isNaN(parsed) ? new Date().getFullYear() : parsed;
    };

    // å»ºç¯‰å®¶ãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›ï¼ˆbuilding_architectsãƒ†ãƒ¼ãƒ–ãƒ«ã®ã¿ã‹ã‚‰å–å¾—ï¼‰
    let architects: any[] = [];
    if (data.building_architects && data.building_architects.length > 0) {
      try {
        // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰å®¶ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const architectPromises = data.building_architects.map(async (ba: any) => {
          const architectId = ba.architect_id;
          if (!architectId) return null;

          // architect_compositionsãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å€‹åˆ¥å»ºç¯‰å®¶IDã‚’å–å¾—
          const { data: compositions, error: compError } = await supabase
            .from('architect_compositions')
            .select(`
              individual_architect_id,
              order_index,
              individual_architects!inner(
                individual_architect_id,
                name_ja,
                name_en,
                slug
              )
            `)
            .eq('architect_id', architectId)
            .order('order_index');

          if (compError || !compositions) {
            console.warn(`å»ºç¯‰å®¶æ§‹æˆå–å¾—ã‚¨ãƒ©ãƒ¼ (architect_id: ${architectId}):`, compError);
            return null;
          }

          // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ï¼ˆè¤‡æ•°å€‹äººã‚’å±•é–‹ï¼‰
          return compositions.map((comp: any) => ({
            architect_id: architectId,
            individual_architect_id: comp.individual_architect_id,
            architectJa: comp.individual_architects.name_ja,
            architectEn: comp.individual_architects.name_en,
            slug: comp.individual_architects.slug,
            order_index: comp.order_index,
            websites: []
          }));
        });

        // ã™ã¹ã¦ã®å»ºç¯‰å®¶ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const architectResults = await Promise.all(architectPromises);
        
        // çµæœã‚’å¹³å¦åŒ–ã—ã¦é…åˆ—ã«å¤‰æ›
        architects = architectResults
          .filter(result => result !== null)
          .flat()
          .filter(architect => architect !== null);

        console.log('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‹ã‚‰å–å¾—ã—ãŸå»ºç¯‰å®¶ãƒ‡ãƒ¼ã‚¿:', architects);
      } catch (error) {
        console.error('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        architects = [];
      }
    }
    // architectDetailsãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å‰Šé™¤

    // å¤–éƒ¨å†™çœŸURLã®ç”Ÿæˆï¼ˆç”»åƒãƒã‚§ãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–ï¼‰
    const generatePhotosFromUid = async (uid: string): Promise<Photo[]> => {
      // ç”»åƒãƒã‚§ãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–ã—ã€å…¨ã¦ã®ãƒ‡ãƒ¼ã‚¿ã§ç”»åƒãŒãªã„ã‚‚ã®ã¨ã—ã¦æ‰±ã†
      return [];
    };

    // å†™çœŸãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆç”»åƒãªã—ï¼‰
    const photos = await generatePhotosFromUid(data.uid);
    
    return {
      id: data.building_id,
      uid: data.uid,
      slug: data.slug, // slugãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¿½åŠ 
      title: data.title,
      titleEn: data.titleEn || data.title,
      thumbnailUrl: data.thumbnailUrl || '',
      youtubeUrl: data.youtubeUrl || '',
      completionYears: parseYear(data.completionYears),
      parentBuildingTypes: parseCommaSeparated(data.parentBuildingTypes),
      buildingTypes: parseSlashSeparated(data.buildingTypes),
      parentStructures: parseCommaSeparated(data.parentStructures),
      structures: parseCommaSeparated(data.structures),
      prefectures: data.prefectures,
      prefecturesEn: data.prefecturesEn || null,
      areas: data.areas,
      location: data.location,
      locationEn: data.locationEn_from_datasheetChunkEn || data.location,
      buildingTypesEn: parseSlashSeparated(data.buildingTypesEn),
      architectDetails: data.architectDetails || '',
      lat: parseFloat(data.lat) || 0,
      lng: parseFloat(data.lng) || 0,
      architects: architects,
      photos: photos, // å®Ÿéš›ã«å­˜åœ¨ã™ã‚‹å†™çœŸã®ã¿
      likes: 0, // likesã‚«ãƒ©ãƒ ãŒãªã„å ´åˆã¯0
      created_at: data.created_at || new Date().toISOString(),
      updated_at: data.updated_at || new Date().toISOString()
    };
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   * individual_architects ã¨ architect_compositions ã‚’çµåˆã—ã¦å–å¾—
   */
  async getArchitectWithNewStructure(architectId: number): Promise<NewArchitect | null> {
    const { data, error } = await supabase
      .from('architect_compositions')
      .select(`
        architect_id,
        order_index,
        individual_architects!inner(
          individual_architect_id,
          name_ja,
          name_en,
          slug
        )
      `)
      .eq('architect_id', architectId)
      .order('order_index')
      .single();

    if (error || !data) {
      console.error('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return null;
    }

    return {
      architect_id: data.architect_id,
      architectJa: data.individual_architects.name_ja,
      architectEn: data.individual_architects.name_en,
      slug: data.individual_architects.slug,
      individual_architect_id: data.individual_architects.individual_architect_id,
      order_index: data.order_index,
      websites: [] // å¿…è¦ã«å¿œã˜ã¦å–å¾—
    };
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰å®¶ã®slugã‹ã‚‰å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   */
  async getArchitectBySlugWithNewStructure(slug: string): Promise<NewArchitect | null> {
    const { data, error } = await supabase
      .from('individual_architects')
      .select(`
        individual_architect_id,
        name_ja,
        name_en,
        slug,
        architect_compositions!inner(
          architect_id,
          order_index
        )
      `)
      .eq('slug', slug)
      .single();

    if (error || !data) {
      console.error('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶slugå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return null;
    }

    // æœ€åˆã®compositionã‚’å–å¾—ï¼ˆè¤‡æ•°ã‚ã‚‹å ´åˆã¯order_indexã§ã‚½ãƒ¼ãƒˆï¼‰
    const composition = data.architect_compositions.sort((a, b) => a.order_index - b.order_index)[0];

    return {
      architect_id: composition.architect_id,
      architectJa: data.name_ja,
      architectEn: data.name_en,
      slug: data.slug,
      individual_architect_id: data.individual_architect_id,
      order_index: composition.order_index,
      websites: [] // å¿…è¦ã«å¿œã˜ã¦å–å¾—
    };
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰ç‰©ã®å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   */
  async getBuildingArchitectsWithNewStructure(buildingId: number): Promise<NewArchitect[]> {
    try {
      console.log(`ğŸ” æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰ç‰©å»ºç¯‰å®¶å–å¾—é–‹å§‹: ${buildingId}`);
      
      // æ®µéšçš„ã«ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã—ã¦å•é¡Œã‚’ç‰¹å®š
      const { data, error } = await supabase
        .from('building_architects')
        .select(`
          architect_id,
          architect_order
        `)
        .eq('building_id', buildingId)
        .order('architect_order');

      if (error || !data) {
        console.error('building_architectså–å¾—ã‚¨ãƒ©ãƒ¼:', error);
        return [];
      }

      console.log(`âœ… building_architectså–å¾—æˆåŠŸ: ${data.length}ä»¶`, data);

      // å„architect_idã«å¯¾ã—ã¦å€‹åˆ¥ã«å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
      const architects: NewArchitect[] = [];
      
      for (const buildingArchitect of data) {
        try {
          // architect_compositionsã‹ã‚‰å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—ï¼ˆã™ã¹ã¦ã®individual_architect_idã‚’å–å¾—ï¼‰
          const { data: compositionData, error: compositionError } = await supabase
            .from('architect_compositions')
            .select(`
              order_index,
              individual_architects(
                individual_architect_id,
                name_ja,
                name_en,
                slug
              )
            `)
            .eq('architect_id', buildingArchitect.architect_id)
            .order('order_index');

          if (compositionError || !compositionData) {
            console.warn(`architect_compositionså–å¾—ã‚¨ãƒ©ãƒ¼ (architect_id: ${buildingArchitect.architect_id}):`, compositionError);
            continue;
          }

          console.log(`âœ… architect_compositionså–å¾—æˆåŠŸ (architect_id: ${buildingArchitect.architect_id}): ${compositionData.length}ä»¶`, compositionData);

          // å„compositionã«å¯¾ã—ã¦å»ºç¯‰å®¶æƒ…å ±ã‚’è¿½åŠ 
          for (const composition of compositionData) {
            if (composition.individual_architects) {
              architects.push({
                architect_id: buildingArchitect.architect_id,
                architectJa: composition.individual_architects.name_ja,
                architectEn: composition.individual_architects.name_en,
                slug: composition.individual_architects.slug,
                individual_architect_id: composition.individual_architects.individual_architect_id,
                order_index: composition.order_index,
                websites: []
              });
              
              console.log(`âœ… å»ºç¯‰å®¶è¿½åŠ : ${composition.individual_architects.name_ja} (${composition.individual_architects.slug})`);
            }
          }
        } catch (compositionError) {
          console.warn(`å€‹åˆ¥å»ºç¯‰å®¶æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼ (architect_id: ${buildingArchitect.architect_id}):`, compositionError);
          continue;
        }
      }

      // individual_architect_idãƒ™ãƒ¼ã‚¹ã§ãƒ¦ãƒ‹ãƒ¼ã‚¯ãªå»ºç¯‰å®¶ã®ã¿ã‚’è¿”ã™
      const uniqueArchitects = architects.filter((architect, index, self) => 
        index === self.findIndex(a => a.individual_architect_id === architect.individual_architect_id)
      );

      console.log(`âœ… æœ€çµ‚çš„ãªå»ºç¯‰å®¶æƒ…å ±: ${uniqueArchitects.length}ä»¶ (é‡è¤‡é™¤å»å¾Œ)`, uniqueArchitects);
      return uniqueArchitects;

    } catch (error) {
      console.error('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰ç‰©å»ºç¯‰å®¶å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’ä½¿ç”¨ã—ãŸå»ºç¯‰ç‰©ãƒ‡ãƒ¼ã‚¿å¤‰æ›ï¼ˆæ—¢å­˜transformBuildingã¨ã®äº’æ›æ€§ã‚’ä¿ã¤ï¼‰
   */
  async transformBuildingWithNewStructure(data: any): Promise<Building> {
    // æ—¢å­˜ã®transformBuildingãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã«å¯¾å¿œ
    const architects = await this.getBuildingArchitectsWithNewStructure(data.building_id);

    // å¤–éƒ¨å†™çœŸURLã®ç”Ÿæˆï¼ˆç”»åƒãƒã‚§ãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–ï¼‰
    const generatePhotosFromUid = async (uid: string): Promise<Photo[]> => {
      return [];
    };

    const photos = await generatePhotosFromUid(data.uid);
    
    return {
      id: data.building_id,
      uid: data.uid,
      slug: data.slug,
      title: data.title,
      titleEn: data.titleEn || data.title,
      thumbnailUrl: data.thumbnailUrl || '',
      youtubeUrl: data.youtubeUrl || '',
      completionYears: parseYear(data.completionYears),
      parentBuildingTypes: parseCommaSeparated(data.parentBuildingTypes),
      buildingTypes: parseSlashSeparated(data.buildingTypes),
      parentStructures: parseCommaSeparated(data.parentStructures),
      structures: parseCommaSeparated(data.structures),
      prefectures: data.prefectures,
      prefecturesEn: data.prefecturesEn || null,
      areas: data.areas,
      location: data.location,
      locationEn: data.locationEn_from_datasheetChunkEn || data.location,
      buildingTypesEn: parseSlashSeparated(data.buildingTypesEn),
      architectDetails: data.architectDetails || '',
      lat: parseFloat(data.lat) || 0,
      lng: parseFloat(data.lng) || 0,
      architects: architects,
      photos: photos,
      likes: 0,
      created_at: data.created_at || new Date().toISOString(),
      updated_at: data.updated_at || new Date().toISOString()
    };
  }

  // ========================================
  // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè£…ãƒ¡ã‚½ãƒƒãƒ‰
  // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’å„ªå…ˆã—ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã§æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½¿ç”¨
  // ========================================

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   */
  async getArchitectHybrid(architectId: number): Promise<Architect | null> {
    try {
      console.log(`ğŸ” æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶å–å¾—é–‹å§‹: ${architectId}`);
      
      // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨
      const newStructureResult = await this.getArchitectWithNewStructure(architectId);
      
      if (newStructureResult) {
        console.log(`âœ… æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶å–å¾—æˆåŠŸ: ${architectId}`);
        return newStructureResult;
      } else {
        console.log(`âš ï¸ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“: ${architectId}`);
        return null;
      }
    } catch (error) {
      console.error('âŒ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return null;
    }
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰å®¶ã‚’æ¤œç´¢
   */
  async searchArchitectsHybrid(query: string, language: 'ja' | 'en' = 'ja'): Promise<Architect[]> {
    try {
      console.log(`ğŸ” æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶æ¤œç´¢é–‹å§‹: ${query}`);
      
      // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨
      const newStructureResults = await this.searchArchitectsWithNewStructure(query, language);
      
      if (newStructureResults.length > 0) {
        console.log(`âœ… æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§æ¤œç´¢æˆåŠŸ: ${query} (${newStructureResults.length}ä»¶)`);
        return newStructureResults;
      } else {
        console.log(`âš ï¸ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶æ¤œç´¢çµæœãŒã‚ã‚Šã¾ã›ã‚“: ${query}`);
        return [];
      }
    } catch (error) {
      console.error('âŒ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰å®¶slugã‹ã‚‰å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   */
  async getArchitectBySlugHybrid(slug: string): Promise<Architect | null> {
    try {
      console.log(`ğŸ” æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶slugå–å¾—é–‹å§‹: ${slug}`);
      
      // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨
      const newStructureResult = await this.getArchitectBySlugWithNewStructure(slug);
      
      if (newStructureResult) {
        console.log(`âœ… æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶slugå–å¾—æˆåŠŸ: ${slug}`);
        return newStructureResult;
      } else {
        console.log(`âš ï¸ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰å®¶slugæƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“: ${slug}`);
        return null;
      }
    } catch (error) {
      console.error('âŒ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶slugå–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return null;
    }
  }

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰ç‰©ã®å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   */
  async getBuildingArchitectsHybrid(buildingId: number): Promise<Architect[]> {
    try {
      console.log(`ğŸ” æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰ç‰©å»ºç¯‰å®¶å–å¾—é–‹å§‹: ${buildingId}`);
      
      // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨
      const newStructureResults = await this.getBuildingArchitectsWithNewStructure(buildingId);
      
      if (newStructureResults.length > 0) {
        console.log(`âœ… æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰ç‰©å»ºç¯‰å®¶å–å¾—æˆåŠŸ: ${buildingId} (${newStructureResults.length}ä»¶)`);
        return newStructureResults;
      } else {
        console.log(`âš ï¸ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰ç‰©å»ºç¯‰å®¶æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“: ${buildingId}`);
        return [];
      }
    } catch (error) {
      console.error('âŒ æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰ç‰©å»ºç¯‰å®¶å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }
  }

  /**
   * å»ºç¯‰å®¶ãƒšãƒ¼ã‚¸å°‚ç”¨: æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨ã—ã¦å»ºç¯‰ç‰©ã®å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—
   */
  async getBuildingArchitectsForArchitectPage(buildingId: number): Promise<Architect[]> {
    try {
      console.log(`ğŸ” å»ºç¯‰å®¶ãƒšãƒ¼ã‚¸ç”¨å»ºç¯‰å®¶æƒ…å ±å–å¾—: ${buildingId}`);
      
      // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ã‚’ä½¿ç”¨
      const newStructureResults = await this.getBuildingArchitectsWithNewStructure(buildingId);
      
      if (newStructureResults.length > 0) {
        console.log(`âœ… å»ºç¯‰å®¶ãƒšãƒ¼ã‚¸ç”¨å»ºç¯‰å®¶æƒ…å ±å–å¾—æˆåŠŸ: ${buildingId} (${newStructureResults.length}ä»¶)`);
        return newStructureResults;
      } else {
        console.log(`âš ï¸ å»ºç¯‰å®¶ãƒšãƒ¼ã‚¸ç”¨å»ºç¯‰å®¶æƒ…å ±ãŒå–å¾—ã§ãã¾ã›ã‚“: ${buildingId}`);
        return [];
      }
    } catch (error) {
      console.error('âŒ å»ºç¯‰å®¶ãƒšãƒ¼ã‚¸ç”¨å»ºç¯‰å®¶æƒ…å ±å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }
  }

  /**
   * å»ºç¯‰å®¶ã®ä½œå“ä¸€è¦§ã‚’å–å¾—ï¼ˆslugãƒ™ãƒ¼ã‚¹ï¼‰
   */
  async getArchitectBuildingsBySlug(slug: string): Promise<{ buildings: Building[], architectName: { ja: string, en: string } }> {
    try {
      console.log(`ğŸ” å»ºç¯‰å®¶ã®ä½œå“å–å¾—é–‹å§‹: ${slug}`);
      
      // 1. individual_architectsãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰individual_architect_idã‚’å–å¾—
      const { data: individualArchitect, error: individualError } = await supabase
        .from('individual_architects')
        .select('individual_architect_id, name_ja, name_en')
        .eq('slug', slug)
        .single();
      
      if (individualError || !individualArchitect) {
        console.log(`âŒ individual_architectsãƒ†ãƒ¼ãƒ–ãƒ«ã§å»ºç¯‰å®¶ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${slug}`);
        return { buildings: [], architectName: { ja: '', en: '' } };
      }
      
      console.log(`âœ… individual_architect_idå–å¾—: ${individualArchitect.individual_architect_id}`);
      
      // 2. architect_compositionsãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰architect_idã‚’å–å¾—
      const { data: compositions, error: compositionsError } = await supabase
        .from('architect_compositions')
        .select('architect_id')
        .eq('individual_architect_id', individualArchitect.individual_architect_id);
      
      if (compositionsError || !compositions || compositions.length === 0) {
        console.log(`âŒ architect_compositionsãƒ†ãƒ¼ãƒ–ãƒ«ã§é–¢é€£ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${individualArchitect.individual_architect_id}`);
        return { buildings: [], architectName: { ja: individualArchitect.name_ja, en: individualArchitect.name_en } };
      }
      
      const architectIds = compositions.map(comp => comp.architect_id);
      console.log(`âœ… architect_idå–å¾—: ${architectIds.join(', ')}`);
      
      // 3. building_architectsãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰building_idã‚’å–å¾—
      const { data: buildingArchitects, error: buildingArchitectsError } = await supabase
        .from('building_architects')
        .select('building_id')
        .in('architect_id', architectIds);
      
      if (buildingArchitectsError || !buildingArchitects || buildingArchitects.length === 0) {
        console.log(`âŒ building_architectsãƒ†ãƒ¼ãƒ–ãƒ«ã§å»ºç¯‰ç‰©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${architectIds.join(', ')}`);
        return { buildings: [], architectName: { ja: individualArchitect.name_ja, en: individualArchitect.name_en } };
      }
      
      const buildingIds = buildingArchitects.map(ba => ba.building_id);
      console.log(`âœ… building_idå–å¾—: ${buildingIds.join(', ')}`);
      
      // 4. buildings_table_2ã‹ã‚‰å»ºç¯‰ç‰©æƒ…å ±ã‚’å–å¾—ï¼ˆé€šå¸¸ã®å»ºç¯‰ç‰©ä¸€è¦§ãƒšãƒ¼ã‚¸ã¨åŒæ§˜ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é©ç”¨ï¼‰
      const { data: buildingsData, error: buildingsError } = await supabase
        .from('buildings_table_2')
        .select(`
          *,
          building_architects!inner(
            architect_id,
            architect_order
          )
        `)
        .in('building_id', buildingIds)
        .not('lat', 'is', null)  // åº§æ¨™ãŒå­˜åœ¨ã™ã‚‹ã‚‚ã®ã®ã¿
        .not('lng', 'is', null)  // åº§æ¨™ãŒå­˜åœ¨ã™ã‚‹ã‚‚ã®ã®ã¿
        .not('buildingTypes', 'eq', 'ä½å®…')  // ä½å®…ã‚’é™¤å¤–
        .not('buildingTypesEn', 'eq', 'housing')  // è‹±èªç‰ˆä½å®…ã‚‚é™¤å¤–
        .order('completionYears', { ascending: false });
      
      if (buildingsError || !buildingsData) {
        console.log(`âŒ buildings_table_2ã§å»ºç¯‰ç‰©ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼: ${buildingsError?.message}`);
        return { buildings: [], architectName: { ja: individualArchitect.name_ja, en: individualArchitect.name_en } };
      }
      
      console.log(`âœ… å»ºç¯‰ç‰©ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é©ç”¨å¾Œï¼‰: ${buildingsData.length}ä»¶`);
      console.log(`ğŸ” é©ç”¨ã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼: lat/lngéNULLã€ä½å®…é™¤å¤–`);
      
      // 5. å»ºç¯‰ç‰©ãƒ‡ãƒ¼ã‚¿ã‚’å¤‰æ›ï¼ˆå»ºç¯‰å®¶æƒ…å ±ã‚’å«ã‚€ï¼‰
      const transformedBuildings = await Promise.all(
        buildingsData.map(async (building) => {
          // å»ºç¯‰å®¶æƒ…å ±ã‚’æ˜ç¤ºçš„ã«å–å¾—ï¼ˆå»ºç¯‰å®¶ãƒšãƒ¼ã‚¸å°‚ç”¨: æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®ã¿ï¼‰
          const buildingArchitects = await this.getBuildingArchitectsForArchitectPage(building.building_id);
          
          // å»ºç¯‰å®¶æƒ…å ±ã®è©³ç´°ãƒ­ã‚°
          console.log(`ğŸ” å»ºç¯‰ç‰© ${building.building_id} ã®å»ºç¯‰å®¶æƒ…å ±:`, buildingArchitects.map(arch => ({
            architect_id: arch.architect_id,
            architectJa: arch.architectJa,
            architectEn: arch.architectEn,
            slug: arch.slug
          })));
          
          // å¤–éƒ¨å†™çœŸURLã®ç”Ÿæˆï¼ˆç”»åƒãƒã‚§ãƒƒã‚¯ã‚’ç„¡åŠ¹åŒ–ï¼‰
          const generatePhotosFromUid = async (uid: string): Promise<any[]> => {
            return [];
          };

          const photos = await generatePhotosFromUid(building.uid);
          
          // ãƒ‡ãƒ¼ã‚¿ã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã¨é©åˆ‡ãªå‡¦ç†
          const hasLocation = building.location && building.location.trim() !== '';
          const hasPrefectures = building.prefectures && building.prefectures.trim() !== '';
          const hasBuildingTypes = building.buildingTypes && building.buildingTypes.trim() !== '';
          const hasCompletionYears = building.completionYears && building.completionYears > 0;
          
          console.log(`ğŸ” å»ºç¯‰ç‰© ${building.building_id} ã®ãƒ‡ãƒ¼ã‚¿çŠ¶æ³:`, {
            hasLocation,
            hasPrefectures,
            hasBuildingTypes,
            hasCompletionYears,
            architectsCount: buildingArchitects.length
          });
          
          return {
            id: building.building_id,
            uid: building.uid,
            slug: building.slug,
            title: building.title,
            titleEn: building.titleEn || building.title,
            thumbnailUrl: building.thumbnailUrl || '',
            youtubeUrl: building.youtubeUrl || '',
            completionYears: hasCompletionYears ? building.completionYears : null,
            parentBuildingTypes: building.parentBuildingTypes ? building.parentBuildingTypes.split(',').map(s => s.trim()).filter(s => s) : [],
            buildingTypes: hasBuildingTypes ? building.buildingTypes.split('/').map(s => s.trim()).filter(s => s) : [],
            parentStructures: building.parentStructures ? building.parentStructures.split(',').map(s => s.trim()).filter(s => s) : [],
            structures: building.structures ? building.structures.split(',').map(s => s.trim()).filter(s => s) : [],
            prefectures: hasPrefectures ? building.prefectures : null,
            prefecturesEn: building.prefecturesEn || null,
            areas: building.areas,
            location: hasLocation ? building.location : null,
            locationEn: building.locationEn_from_datasheetChunkEn || building.location,
            buildingTypesEn: building.buildingTypesEn ? building.buildingTypesEn.split('/').map(s => s.trim()).filter(s => s) : [],
            architectDetails: building.architectDetails || '',
            lat: parseFloat(building.lat) || 0,
            lng: parseFloat(building.lng) || 0,
            architects: buildingArchitects,
            photos: photos,
            likes: building.likes || 0,
            created_at: building.created_at || new Date().toISOString(),
            updated_at: building.updated_at || new Date().toISOString()
          };
        })
      );
      
      console.log(`âœ… å»ºç¯‰ç‰©ãƒ‡ãƒ¼ã‚¿å¤‰æ›å®Œäº†: ${transformedBuildings.length}ä»¶`);
      console.log(`ğŸ” æœ€åˆã®å»ºç¯‰ç‰©ã®å»ºç¯‰å®¶æƒ…å ±:`, transformedBuildings[0]?.architects);
      console.log(`ğŸ” æœ€åˆã®å»ºç¯‰ç‰©ã®ç”¨é€”æƒ…å ±:`, transformedBuildings[0]?.buildingTypes);
      console.log(`ğŸ” æœ€åˆã®å»ºç¯‰ç‰©ã®å®Œæˆå¹´:`, transformedBuildings[0]?.completionYears);
      console.log(`ğŸ” å»ºç¯‰å®¶ãƒšãƒ¼ã‚¸ç”¨: æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‹ã‚‰å»ºç¯‰å®¶æƒ…å ±ã‚’å–å¾—å®Œäº†`);
      
      return {
        buildings: transformedBuildings,
        architectName: {
          ja: individualArchitect.name_ja,
          en: individualArchitect.name_en
        }
      };
      
    } catch (error) {
      console.error('âŒ å»ºç¯‰å®¶ã®ä½œå“å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return { buildings: [], architectName: { ja: '', en: '' } };
    }
  }

  /**
   * ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å»ºç¯‰ç‰©ãƒ‡ãƒ¼ã‚¿å¤‰æ›ï¼ˆæ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ å„ªå…ˆï¼‰
   */
  async transformBuildingHybrid(data: any): Promise<Building> {
    try {
      // 1. æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§è©¦è¡Œ
      const newStructureResult = await this.transformBuildingWithNewStructure(data);
      if (newStructureResult) {
        console.log(`âœ… æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§å»ºç¯‰ç‰©å¤‰æ›æˆåŠŸ: ${data.building_id}`);
        return newStructureResult;
      }
      
      // 2. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®transformBuilding
      console.log(`ğŸ”„ ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ã§å»ºç¯‰ç‰©å¤‰æ›: ${data.building_id}`);
      return await this.transformBuilding(data);
    } catch (error) {
      console.error('âŒ ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å»ºç¯‰ç‰©å¤‰æ›ã‚¨ãƒ©ãƒ¼:', error);
      // æœ€å¾Œã®æ‰‹æ®µ: åŸºæœ¬çš„ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§è¿”ã™
      return {
        id: data.building_id,
        uid: data.uid || '',
        slug: data.slug || '',
        title: data.title || '',
        titleEn: data.titleEn || data.title || '',
        thumbnailUrl: data.thumbnailUrl || '',
        youtubeUrl: data.youtubeUrl || '',
        completionYears: 0,
        parentBuildingTypes: [],
        buildingTypes: [],
        parentStructures: [],
        structures: [],
        prefectures: data.prefectures || '',
        prefecturesEn: data.prefecturesEn || null,
        areas: data.areas || '',
        location: data.location || '',
        locationEn: data.locationEn || null,
        buildingTypesEn: [],
        architectDetails: data.architectDetails || '',
        lat: parseFloat(data.lat) || 0,
        lng: parseFloat(data.lng) || 0,
        architects: [],
        photos: [],
        likes: 0,
        created_at: data.created_at || new Date().toISOString(),
        updated_at: data.updated_at || new Date().toISOString()
      };
    }
  }

  /**
   * ç§»è¡ŒçŠ¶æ³ã®ç¢ºèª
   */
  async getMigrationStatus(): Promise<{
    newStructureAvailable: boolean;
    fallbackUsed: boolean;
    lastMigrationCheck: string;
  }> {
    try {
      // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã®å¯ç”¨æ€§ã‚’ç¢ºèª
      const { data: individualCount, error: individualError } = await supabase
        .from('individual_architects')
        .select('individual_architect_id', { count: 'exact' });

      const { data: compositionCount, error: compositionError } = await supabase
        .from('architect_compositions')
        .select('architect_id', { count: 'exact' });

      const newStructureAvailable = !individualError && !compositionError && 
        (individualCount || 0) > 0 && (compositionCount || 0) > 0;

      return {
        newStructureAvailable,
        fallbackUsed: false, // ã“ã®å€¤ã¯å®Ÿéš›ã®ä½¿ç”¨çŠ¶æ³ã§æ›´æ–°
        lastMigrationCheck: new Date().toISOString()
      };
    } catch (error) {
      console.error('ç§»è¡ŒçŠ¶æ³ç¢ºèªã‚¨ãƒ©ãƒ¼:', error);
      return {
        newStructureAvailable: false,
        fallbackUsed: false,
        lastMigrationCheck: new Date().toISOString()
      };
    }
  }

  // ========================================
  // æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®æ¤œç´¢ãƒ¡ã‚½ãƒƒãƒ‰
  // ========================================

  /**
   * æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã‚’ä½¿ç”¨ã—ãŸå»ºç¯‰å®¶æ¤œç´¢
   */
  async searchArchitectsWithNewStructure(query: string, language: 'ja' | 'en' = 'ja'): Promise<Architect[]> {
    try {
      const { data, error } = await supabase
        .from('individual_architects')
        .select(`
          individual_architect_id,
          name_ja,
          name_en,
          slug,
          architect_compositions!inner(
            architect_id,
            order_index
          )
        `)
        .or(`name_ja.ilike.%${query}%,name_en.ilike.%${query}%`)
        .order('name_ja');

      if (error || !data) {
        console.error('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶æ¤œç´¢ã‚¨ãƒ©ãƒ¼:', error);
        return [];
      }

      return data.map(item => {
        // æœ€åˆã®compositionã‚’å–å¾—ï¼ˆè¤‡æ•°ã‚ã‚‹å ´åˆã¯order_indexã§ã‚½ãƒ¼ãƒˆï¼‰
        const composition = item.architect_compositions.sort((a: any, b: any) => a.order_index - b.order_index)[0];
        
        return {
          architect_id: composition.architect_id,
          architectJa: item.name_ja,
          architectEn: item.name_en,
          slug: item.slug,
          websites: []
        };
      });
    } catch (error) {
      console.error('æ–°ã—ã„ãƒ†ãƒ¼ãƒ–ãƒ«æ§‹é€ ã§ã®å»ºç¯‰å®¶æ¤œç´¢ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:', error);
      return [];
    }
  }

  /**
   * æ—¢å­˜ã®å»ºç¯‰å®¶æ¤œç´¢ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè£…ã‚’ä½¿ç”¨ï¼‰
   */
  async searchArchitects(query: string, language: 'ja' | 'en' = 'ja'): Promise<Architect[]> {
    // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè£…ã‚’ä½¿ç”¨
    return await this.searchArchitectsHybrid(query, language);
  }
}

export const supabaseApiClient = new SupabaseApiClient();

/**
 * äººæ°—æ¤œç´¢ã‚’å–å¾—
 */
export async function fetchPopularSearches(days: number = 7): Promise<SearchHistory[]> {
  try {
    const { data, error } = await supabase
      .rpc('get_popular_searches', { days })
      .select('*');

    if (error) {
      console.error('äººæ°—æ¤œç´¢ã®å–å¾—ã‚¨ãƒ©ãƒ¼:', error);
      return [];
    }

    if (!data) {
      return [];
    }

    // SearchHistoryå‹ã«å¤‰æ›
    return data.map(item => {
      let filters = null;
      
      // æ¤œç´¢ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æƒ…å ±ã‚’å¾©å…ƒ
      if (item.search_type === 'architect') {
        filters = {
          architects: [item.query]
        };
      } else if (item.search_type === 'prefecture') {
        filters = {
          prefectures: [item.query]
        };
      }
      
      return {
        query: item.query,
        searchedAt: item.last_searched,
        count: item.total_searches,
        type: item.search_type as 'text' | 'architect' | 'prefecture',
        filters: filters
      };
    });
  } catch (error) {
    console.error('äººæ°—æ¤œç´¢ã®å–å¾—ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:', error);
    return [];
  }
}

/**
 * æ¤œç´¢å±¥æ­´ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«å±¥æ­´ã«ä¿å­˜
 */
export async function saveSearchToGlobalHistory(
  query: string,
  searchType: 'text' | 'architect' | 'prefecture',
  filters?: Partial<SearchFilters>,
  userId?: number
): Promise<boolean> {
  // æ™‚é–“åˆ¶é™ãƒã‚§ãƒƒã‚¯
  if (!sessionManager.canSearch(query, searchType)) {
    console.log('é‡è¤‡æ¤œç´¢ã‚’ã‚¹ã‚­ãƒƒãƒ—:', query);
    return false;
  }

  try {
    const { error } = await supabase
      .from('global_search_history')
      .insert({
        query,
        search_type: searchType,
        user_id: userId || null,
        user_session_id: sessionManager.getSessionId(),
        filters: filters || null
      });

    if (error) {
      console.error('ã‚°ãƒ­ãƒ¼ãƒãƒ«æ¤œç´¢å±¥æ­´ã®ä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
      return false;
    }

    console.log('ã‚°ãƒ­ãƒ¼ãƒãƒ«æ¤œç´¢å±¥æ­´ã«ä¿å­˜å®Œäº†:', query);
    return true;
  } catch (error) {
    console.error('ã‚°ãƒ­ãƒ¼ãƒãƒ«æ¤œç´¢å±¥æ­´ã®ä¿å­˜ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ:', error);
    return false;
  }
}